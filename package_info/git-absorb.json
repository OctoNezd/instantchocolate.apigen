{"description": "This is a port of Facebook's [`hg absorb`](https://www.mercurial-scm.org/repo/hg/rev/5111d11b8719), which I first read about on [mozilla.dev.version-control](https://groups.google.com/forum/#!msg/mozilla.dev.version-control/nh4fITFlEMk/ZNXgnAzxAQAJ):\n\n> * Facebook demoed `hg absorb` which is probably the coolest workflow enhancement I've seen to version control in years. Essentially, when your working directory has uncommitted changes on top of draft changesets, you can run `hg absorb` and the uncommitted modifications are automagically folded (\"absorbed\") into the appropriate draft ancestor changesets. This is essentially doing `hg histedit` + \"roll\" actions without having to make a commit or manually make history modification rules. The command essentially looks at the lines that were modified, finds a changeset modifying those lines, and amends that changeset to include your uncommitted changes. If the changes can't be made without conflicts, they remain uncommitted. This workflow is insanely useful for things like applying review feedback. You just make file changes, run `hg absorb` and the mapping of changes to commits sorts itself out. It is magical. \n\n## Elevator Pitch\n\nYou have a feature branch with a few commits. Your teammate reviewed the branch and pointed out a few bugs. You have fixes for the bugs, but you don't want to shove them all into an opaque commit that says `fixes`, because you believe in atomic commits. Instead of manually finding commit SHAs for `git commit --fixup`, or running a manual interactive rebase, do this:\n\n```\ngit add $FILES_YOU_FIXED\ngit absorb --and-rebase\n```\n\n`git absorb` will automatically identify which commits are safe to modify, and which staged changes belong to each of those commits. It will then write `fixup!` commits for each of those changes.\n\nWith the `--and-rebase` flag, these fixup commits will be automatically integrated into the corresponding ones. Alternatively, you can check its output manually if you don't trust it, and then fold the fixups into your feature branch with git's built-in [autosquash](https://git-scm.com/docs/git-rebase#Documentation/git-rebase.txt---autosquash) functionality:\n\n```\ngit add $FILES_YOU_FIXED\ngit absorb\ngit log # check the auto-generated fixup commits\ngit rebase -i --autosquash master\n```\n\n## Usage\n\n1. `git add` any changes that you want to absorb. By design, `git absorb` will only consider content in the git index (staging area).\n2. `git absorb`. This will create a sequence of commits on `HEAD`. Each commit will have a `fixup!` message indicating the message (if unique) or SHA of the commit it should be squashed into.\n3. If you are satisfied with the output, `git rebase -i --autosquash` to squash the `fixup!` commits into their predecessors. You can set the [`GIT_SEQUENCE_EDITOR`](https://stackoverflow.com/a/29094904) environment variable if you don't need to edit the rebase TODO file.\n4. If you are not satisfied (or if something bad happened), `git reset --soft` to the pre-absorption commit to recover your old state. (You can find the commit in question with `git reflog`.) And if you think `git absorb` is at fault, please [file an issue](https://github.com/tummychow/git-absorb/issues/new).", "updated": "2024-03-10T17:03:27Z", "galleryUrl": "https://community.chocolatey.org/packages/git-absorb/0.6.10", "abuseUrl": "https://community.chocolatey.org/package/ReportAbuse/git-absorb/0.6.10", "licenseUrl": "https://github.com/tummychow/git-absorb/blob/master/LICENSE.md", "packageName": "git-absorb", "displayName": "git-absorb", "summary": "git commit --fixup, but automatic", "version": "0.6.10", "icon": "", "author": "Stephen Jung", "downloadCount": 95, "tags": ["git-absorb", "git", "rebase"]}